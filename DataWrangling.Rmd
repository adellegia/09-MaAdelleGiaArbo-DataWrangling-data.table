---
title: "Data Wrangling at Scale with data.table"
output:
  html_document:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: tango
    theme: lumen
    toc_depth: 3
    toc_float: true
    css: custom.css 
    self_contained: false
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```
This presentation will detail data.tables data wrangling functionality, including:

- Data manipulation
- Modifying variables
- Summarizing data
- Chaining
- Joins 
- Plotting data

We will end the presentation with an exercise. 


# What's data wrangling? `r emo::ji("thinking")`
Data wrangling is the process of converting raw data to another format which can be readily analyzable. 

```{r, fig.align='center', echo=F, out.width = "70%"}
      knitr::include_graphics("pics/data_wrangling.png")
```

# data.table `r emo::ji("video")`
`data.table` provides an efficient and high performance alternative of base R's data.frame when conducting data wrangling. 

`data.table` enables this efficiency by providing: 

- concise syntax: fast to type, fast to read
- fast speed
- memory efficiency
- careful API lifecycle management
- a large community
- rich features

## Importing with `fread()`

`data.table`'s efficiency begins from the outset with `fread()`, which is short for fast read is data.table's version of `read_csv()`.

Let's download and read the `mtcars` dataset and call it `mt` using `fread()`.
```{r}
library(dplyr)
library(data.table)
mt <- as.data.frame(fread("mtcars.csv"))
```

Let's check how fast `fread()` actually is it compared to `read.csv`. You can also write a file using `fwrite()` in `data.table` like `write.csv`. 
```{r}
# Create a large .csv file
set.seed(28)
trial <- data.frame(matrix(runif(10000000), nrow=1000000))
#write.csv(trial, 'trial.csv', row.names = F)
```

We can then see that `fread()` is at least 20 times faster! Let's check it out!
```{r}
# Time taken by read.csv to import
#system.time({trial_df <- read.csv('trial.csv')})

# Time taken by fread to import
#system.time({trial_df <- fread('trial.csv')})
```

## Creating data tables
To highlight what a data table is, we will create data tables using different functions and compare the results with a data frame. Let's use a built-in R data called `airquality`.
```{r}
head(airquality)
class(airquality)
```
To convert this data frame to a data table, we can either use:

* `data.table()` and `as.data.table()` - This function creates a copy of the data and converts it to a data.table

* `setDT()` - This function converts the data to a data.table, there is then no need to assign to a new object

We convert `airquality` data frame to a data table using `as.data.table`. It then becomes both a data table and a data frame.
```{r}
class(airquality)
airqualityDT <- as.data.table(airquality)
class(airqualityDT)
```

Now, we do the same for the `mt` data frame.
```{r}
class(mt)
setDT(mt) # we do not need to assign mt to a new object
class(mt)

# for illustration purposes, let's use `as.data.table` and assign it to mtDT
mtDT <- as.data.table(mt)
class(mtDT)
```

We can "manually" create a data table using `data.table()`.
```{r}
DT <- data.table(x = 1:8,
                 y = round(pi*1:8,2),
                 z = letters[1:8])
knitr::kable(DT)
```

Packages and functions that work with data frames also work for data tables. Since a data.table is a data.frame, it is compatible with R functions and packages that accept only data.frames.
```{r}
names(mtDT)
dim(mtDT)
str(mtDT)
```

For reference, the `mt` data has the following variables:

- [, 1]	**carname**   - Car name
- [, 2]	**mpg**   - Miles/(US) gallon
- [, 3]	**cyl**   - Number of cylinders
- [, 4]	**disp**  - Displacement (cu.in.)
- [, 5]	**hp**    - Gross horsepower
- [, 6]	**drat**  - Rear axle ratio
- [, 7]	**wt**    - Weight (1000 lbs)
- [, 8]	**qsec**  - 1/4 mile time
- [, 9]	**vs**    - Engine (0 = V-shaped, 1 = straight)
- [,10]	**am**    - Transmission (0 = automatic, 1 = manual)
- [,11]	**gear**  - Number of forward gears
- [,12]	**carb**  - Number of carburetors


# Data manipulation with `data.table` `r emo::ji("car")`
When compared to a data frame, the basic arguments within brackets are **NOT** row and column numbers but rather "i", "j" and "by". 

For example, a data table named DT, DT[i, j, by] translates to "Take DT, subset rows using **i**, then calculate **j** grouped by **by**".

```{r, fig.align='center', echo=F, out.width = "70%"}
      knitr::include_graphics("pics/data_table_syntax.png")
```

Let's compare filtering using conditional statements in a data frame vs. in a data table. 
You will notice one of the primary benefits of data table, you only need to pass the column names!
```{r}
mt[mt$cyl == 6 & mt$gear == 4, ]

# datatable syntax
mtDT[cyl==6 & gear==4, ]
```

## Filtering rows
Selecting rows is largely similar to data frame.

```{r}
# select a row
mtDT[1,]

# selecting first five rows
mtDT[1:5,]

# no need to put comma in selecting rows
mtDT[1:2]

# subsetting using conditional statements
mtDT[cyl < 5 & am == 0]
```

## Selecting columns
There are some pointers you have to remember to select  a column.
```{r}
# using index
mtDT[,1:2]

# using column name
mtDT[ , mpg] # returns a vector
mtDT[ , "mpg"] # returns the column

# selecting multiple columns using "list" or puting inside ".()"
mtDT[, list(mpg, cyl)]
mtDT[, .(mpg, cyl)]

# selecting multiple columns using a character vector
col <- c('mpg', 'cyl', 'disp')

#mtDT[, col] # returns an error

# need to put, with = FALSE, or add ".." before the character vector
mtDT[, col, with = FALSE]
mtDT[, ..col]
```

## Subsetting rows and columns
Combing what we learned above, we can filter rows and select columns together from a data table.
```{r}
# selecting first row, second column
mtDT[1,2] # returns the column

mtDT[1,cyl] # returns a vector

mtDT[1,"cyl"] # returns the column

mtDT[1,list(mpg, cyl)] # returns the column

mtDT[1, .(mpg, cyl)] # returns the column

mtDT[1, c(mpg, cyl)] # returns a vector
```

# Modifying variables `r emo::ji("key")`

Data.table also makes it easy to:

- Drop columns; 
- Rename columns; and 
- Assign and save new variables. 

## Dropping columns
```{r}
col <- c('mpg', 'cyl', 'disp')

mtDT[, !col, with = FALSE]
mtDT[, !..col, with = FALSE] # note: you need to assign this to a new object to make a new data table excluding the dropped variables
```

## Renaming columns using `setnames()`
```{r}
setnames(mtDT, 'vs', 'engine_type')
names(mtDT) # vs renamed to engine_type
```

## Assigning and saving new variables
To create a new column, we use this symbol `:=` to assign the new variable.
```{r}
mtDT[, cyl_gear := cyl + gear]

mtDT[, cyl_gear] # returns a vector
mtDT[, "cyl_gear"] # returns the column
```

We can also create multiple columns like using `mutate()` in `dplyr`. In  `data.table`, we only need to put back single quotes to `:=` and assign new variables.
```{r}
mtDT[,  `:=`(cyl_gear2 = cyl * gear,
             cyl_gear3 = cyl - gear)]
names(mtDT)
head(mtDT[, list(cyl_gear2, cyl_gear3)])
```

# Summarizing data `r emo::ji("desktop")`
Summarising data is more readable and easier to type as it takes fewer key strokes compared to `dplyr`. 

```{r}
mtDT[,(mean_hp = mean(hp))] # returns a vector

# Notice what happens using "."
mtDT[,.(mean_hp = mean(hp))] # returns name

mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp))] # without the "." at the beggining, you will get an error

mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp)), by = .(engine_type)]

# you can remove the . if you're only grouping using one variable
mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp)), by = engine_type]
```

# Chaining `r emo::ji("cell")`
Chaining is like piping in `dplyr`. You only need to attach square brackets at the end, with your method, to add an additional step in the analysis. 

For example, we want to return the average mpg, disp, wt, qsec. Then, order the results by cyl.
```{r}
mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), by=cyl]


mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), by=cyl][order(cyl),]
```

Recall that the `dplyr` piping version of this is:
```{r}
mtDT %>%
  group_by(cyl) %>%
  summarise(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)) %>%
  arrange(cyl)
```

# Joins with `data.table` `r emo::ji("family")`
## Key
The concept of a "key" is useful in data tables, especially in merging data. We can set a column as a key using `setkey()`.
```{r}
setkey(mtDT, carname) # setting carname as key
setkey(mtDT, carname, cyl) # setting multiple keys
```

Remember the chaining example a while ago. We grouped and ordered by `cyl`. Let's re-do that using a shortcut by using `keyby`.
```{r}
# instead of using this chain
mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), by=cyl][order(cyl), ]

# use keyby to group and order by cyl
mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), keyby=cyl]
key(mtDT)

setkey(mtDT, NULL) # to remove the key
```

## Joining data tables
Now that we know what a key is, we can use this concept to merge or join two data tables.
```{r}
setkey(mtDT, carname)

# we subset 3 data tables with 10 rows
dt1 <- mtDT[5:25,.(carname, mpg, cyl)]
dt2 <- mtDT[1:10, .(carname, gear)]
dt3 <- mtDT[2:12, .(carname, disp)]

# Inner Join
merge(dt1, dt2, by='carname') # returns 6 rows from row 5 to 10

# Left Join
merge(dt1, dt2, by='carname', all.x = T) # returns 21 rows using dt1 as the base

# Outer Join
merge(dt1, dt2, by='carname', all = T)  # returns 25 rows
```

# Plotting data `r emo::ji("chart")`
```{r}
mtDT[,plot(mpg, drat, main="mpg vs. drat")]
```

# Further readings `r emo::ji("student")`
`data.table` has many other functions including:

- `dcast` - pivot/wider/spread
- `melt()` - unpivot/longer/gather
- `.SD` and `.SDcols`

# Exercise `r emo::ji("sun")`
Using `data.table` and the `mtcars.csv` data.
```{r}

```

# Sources `r emo::ji("teacher")`

This tutorial is partly based on [data.table in R – The Complete Beginners Guide](https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/) by Selva Prabhakaran and [Data Wrangling — Raw to Clean Transformation](https://towardsdatascience.com/data-wrangling-raw-to-clean-transformation-b30a27bf4b3b) by Suraj Gurav.



