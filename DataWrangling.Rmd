---
title: "Data Wrangling at Scale with data.table"
output:
  html_document:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: tango
    theme: lumen
    toc_depth: 3
    toc_float: true
    css: custom.css 
    self_contained: false
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# What's data wrangling? `r emo::ji("thinking")`
Data wrangling is the process of converting raw data to another format which can be readily analyzable. 

# data.table `r emo::ji("video")`
`data.table` provides an efficient and high performance alternative of base R's data.frame when conducting data wrangling. 

`data.table` enables this efficiency by providing: 

- concise syntax: fast to type, fast to read
- fast spee
- memory efficiency
- careful API lifecycle management
- a large community
- rich features

## Importing with `fread()`

Let's download and read the mt dataset using fread.
```{r}
library(data.table)
mt <- fread("https://raw.githubusercontent.com/selva86/datasets/master/mtcars.csv")
```

`fread()` short for fast read is the data.table's version of `read_csv()`. 
`fread()` is at least 20 times faster! Let's check it out!
```{r}
# Create a large .csv file
set.seed(28)
trial <- data.frame(matrix(runif(10000000), nrow=1000000))
#write.csv(trial, 'trial.csv', row.names = F)

# Time taken by read.csv to import
#system.time({trial_df <- read.csv('trial.csv')})

# Time taken by fread to import
#system.time({trial_df <- fread('trial.csv')})
```

## Creating data tables

```{r}
class(airquality)
```
To convert a data frame to a data table, we can either use:

* `data.table()` and `as.data.table()` - creates a copy of the data and converts it to a data.table

* `setDT()` - the data itself gets converted to a data.table, no need to assign to a new object

We use the built-in R data set airquality as an example.
```{r}
class(airquality)
airqualityDT <- as.data.table(airquality)
class(airqualityDT)

mtDT <- as.data.table(mt)
```

We also use `data.table()` to create data tables.
```{r}
DT <- data.table(x = 1:8,
                 y = round(pi*1:8,2),
                 z = letters[1:8])
knitr::kable(DT)
```

Packages and functions that work with data frames also work for data tables.
```{r}
names(mtDT)
dim(mtDT)
str(mtDT)
```
For reference, the mt dataset has the following numeric variables:

- [, 1]	**mpg**   - Miles/(US) gallon
- [, 2]	**cyl**   - Number of cylinders
- [, 3]	**disp**  - Displacement (cu.in.)
- [, 4]	**hp**    - Gross horsepower
- [, 5]	**drat**  - Rear axle ratio
- [, 6]	**wt**    - Weight (1000 lbs)
- [, 7]	**qsec**  - 1/4 mile time
- [, 8]	**vs**    - Engine (0 = V-shaped, 1 = straight)
- [, 9]	**am**    - Transmission (0 = automatic, 1 = manual)
- [,10]	**gear**  - Number of forward gears
- [,11]	**carb**  - Number of carburetors


# Data manipulation with `data.table` 
The basic arguments within brackets are **NOT** row and column numbers but rather "i", "j" and "by". Say you have a data table called DT. In other words, DT[i, j, by] translates to "Take DT, subset rows using **i**, then calculate **j** grouped by **by**".

```{r, fig.align='center', echo=F, out.width = "70%"}
      knitr::include_graphics("pics/data_table_syntax.png")
```

Let's compare filtering using conditional statements in a data frame vs. in a data table. In the data table, you only need to pass the column names!
```{r}
mt[mt$cyl == 6 & mt$gear == 4, ]

# datatable syntax
mtDT[cyl==6 & gear==4, ]
```

## Filtering rows
```{r}
# select a row
mtDT[1,]

# selecting first five rows
mtDT[1:5,]
```

## Selecting columns
```{r}
# no need to put comma in selecting rows
mtDT[1:2]

# selecting columns
mtDT[,1:2]

# no need to put "mtDT$" when calling a variable or column
mtDT[,list(mpg, cyl)]
mtDT[, .(mpg, cyl)]

# selecting multiple columns using a character vector
col <- c('mpg', 'cyl', 'disp')

# returns an error
#mtDT[, col] 

mtDT[, col, with = FALSE]
mtDT[, ..col]
```
## Subsetting rows and columns
```{r}
# selecting first row, second column
mtDT[1,2]

mtDT[1,cyl]

mtDT[1,list(mpg, cyl)]

mtDT[1, .(mpg, cyl)]

# returns a vector
mtDT[1, c(mpg, cyl)]
```

# Modifying variables
## Dropping columns
```{r}
col <- c('mpg', 'cyl', 'disp')

mtDT[, !col, with = FALSE]
mtDT[, !..col, with = FALSE]
```

## Renaming columns using `setnames()`
```{r}
setnames(mtDT, 'vs', 'engine_type')
names(mtDT) # vs renamed to engine_type
```

## Assigning and saving new variables
```{r}
mtDT[, cyl_gear := cyl + gear]

mtDT[, cyl_gear] # returns a vector
mtDT[, "cyl_gear"] # returns the column
```

To create multiple columns,
```{r}
mtDT[,  `:=`(cyl_gear3 = cyl * gear,
                  cyl_gear4 = cyl - gear)]
mtDT
```

# Summarizing data
```{r, fig.align='center', echo=F, out.width = "90%"}
#  knitr::include_graphics("")
```


```{r}
mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp))]

mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp)), by = .(engine_type)]

# you can remove the . if you're only grouping using one variable
mtDT[,.(mean_hp = mean(hp), sd_hp = sd(hp)), by = engine_type]
```

# Chaining
Chaining is like piping in `dplyr`. You only need to attach square brackets at the end to add an additional step in the analysis. For example, we want to return the average mpg, disp, wt, qsec. Then, order the results by cyl.
```{r}
mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), by=cyl]


mtDT[, .(mean_mpg=mean(mpg),
         mean_disp=mean(disp),
         mean_wt=mean(wt),
         mean_qsec=mean(qsec)), by=cyl][order(cyl),]
```

# Plotting data
```{r}
#mtDT[,barplot(vs, mean_hp = mean(hp), main="Average Horsepower"), by = .(carname)]
```


# Exercise
dplyr vs. data.table
```{r}
```
